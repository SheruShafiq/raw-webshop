# Wall Market Online Webshop – Technical Architecture Overview

## Product Catalog Display (Viewing Products and Details)

**Data Retrieval:** On the home page (`index.html`), a script fetches all products from the backend API (a JSON server) when the page loads. The function `loadProducts()` calls `fetchProducts()` which performs a GET request to `/api/products` and returns a list of product objects in JSON. If the fetch succeeds, the product list is passed to `displayProducts()` for rendering; if no products are found, a message “No equipment available.” is shown.

**Rendering Product List:** Each product is rendered as a “product card” in the DOM. The code constructs HTML for these cards in `createProductCard(product)`. This function formats the price, truncates long descriptions, and generates an image carousel if multiple images exist. For example, if a product has multiple image URLs, it creates `<img>` elements and carousel navigation buttons for cycling through images. The resulting card HTML includes the product name, short description, price, and action buttons (View Details, Add to Cart). After assembling all cards, `displayProducts()` injects them into the page’s `<div id="products-container">`. This dynamic generation means the product list on the home page is always up-to-date with the backend data.

**“View Details” Navigation:** Each product card’s "View Details" button is wired to navigate to a detailed product page. Event listeners are attached to all `.view-details-btn` buttons. When clicked, they play a menu sound and call `viewProduct(productId)` after a short transition effect. The `viewProduct` function builds a target URL like `pages/product.html?id=...` and redirects the browser there, passing the product’s ID as a URL query parameter.

**Product Detail Page:** On the product detail page (`product.html`), the script runs `loadProductDetail()` on DOM load if the URL contains a product ID. This function reads the `id` param from `window.location.search` and fetches that specific product via `fetchProduct(productId)` (GET `/api/products/{id}`). While loading, a “Loading product details...” placeholder is shown. If the product is found, `createProductDetail(product)` generates a detailed view: it shows a larger image (or image gallery if multiple images) and full description, along with metadata like category, item ID, creation date, and tags. For example, category names are derived from the product’s `categoryId` by a helper `getCategoryName()` (which maps category IDs to names like “Weapons”, “Materia”, etc.). The price is displayed in an RPG-themed format (“Gil” currency in a styled counter). An “Obtain Item” button (equivalent to Add to Cart) is also provided on this page, along with a Return button to go back.

**Product Interaction – Add to Cart:** Both on the home page and product detail page, an **“Add to Cart”** action is available. On the home page, each product card’s **Add to Cart** button has an event listener that calls `addToCart(productId)` when clicked. The code provides user feedback by temporarily changing the button text to “Adding...” and disabling it while the operation completes. On the product detail page, the “Obtain Item” button similarly triggers `addToCart` for that specific item. These interactions ensure that a user can seamlessly add any product to their shopping cart from either view.

**Search and Filtering:** A search bar (`<input id="product-search">`) on the home page enables filtering of the product list. The function `setupProductSearch(products)` attaches an `input` event handler on the search field. As the user types, it waits for 300ms (“debounce”) and then filters the in-memory `products` array for matches in product name, description, or tags. Matching products are re-rendered by calling `displayProducts(filteredProducts)`. If no items match, the UI displays a “No items found” message inside a styled window panel. This client-side filtering provides a simple way to search the catalog. (There are no advanced category or price filters implemented – category distinctions exist in data and are shown, but there is no UI dropdown to filter by category beyond typing keywords.)

## User Account Management (Registration, Login, Session)

**User Registration:** New users can sign up via a registration form (on the login/register page). The form’s submission is handled by `handleRegister()` in **auth.js**. When the user submits their desired display name, email, password, etc., the function first validates the inputs (e.g. checks password length and that password and confirmation match). If validation passes, it fetches the `/api/users` list to ensure the email isn’t already in use. Assuming the email is unique, a `newUser` object is constructed with fields like `id` (generated as `"USER_" + timestamp`), `displayName`, `email`, `password`, `roleId` (defaulting to 1 for “User” role), and timestamps. This new user is then sent to the backend via a POST request to `/api/users`. On success, a message “New member registered! Access Wall Market now.” is shown to the user and the UI switches to show the login form (`showLoginForm()` is called to let the user log in next). If any error occurs or the account exists, an error message is displayed instead. Passwords are stored in plain text in the JSON database for this demo (no hashing), which is something to be mindful of in a real system.

**User Login:** For returning users, the login form triggers `handleLogin()`. This function reads the entered email and password and fetches the `/api/users` list to find a matching user record. It looks for a user object with the same email/password and also checks that the account is not marked as deleted (`!u.deletedAt`). If a match is found, a second fetch retrieves that user’s role info from `/api/roles/{roleId}` (for example, roleId 2 corresponds to “Admin”). The client then sets `window.currentUser` to an object containing the user’s data and role. This effectively logs the user in on the front-end. The user info is also persisted to `localStorage` under the key `wallMarketUser` so that the session remains if the page is refreshed. On successful login, a “Access granted! Welcome…” message is shown and the page redirects to the home page after 1.5 seconds. If no matching user is found, an “Access denied. Invalid credentials.” error is displayed to the user.

**Session Management and Navigation Updates:** The application uses the presence of `window.currentUser` to track login state globally. On initial load, `initializeAuth()` runs and checks localStorage for a saved user session. If found, it populates `window.currentUser` accordingly so the user stays logged in across visits. The navigation bar is then updated based on the auth state via `updateNavigation()`. This function dynamically alters the top navigation links: if a user is logged in, it removes any old auth links and adds a “Welcome, \[Name]” profile link (with the user’s display name). If the logged-in user’s role is Admin, an additional “Admin Panel” link is added to the nav. If no user is logged in, instead a “Login” link is shown. All these links are given specific IDs (`profile-link`, `admin-link`, `login-link`) and their clicks are handled to route to the appropriate pages (profile page, admin page, or login page). This dynamic nav update ensures that the UI always reflects the current login state (e.g., showing the login option for guests, or the profile/admin options for authenticated users).

**Logout:** The site provides a logout action via a “Logout” button (likely within the profile page or nav). The `handleLogout()` function simply clears the session client-side: it sets `window.currentUser = null` and removes the `wallMarketUser` item from localStorage, then redirects the user to the home page. After logout, the nav will again update (since no currentUser, it will show the Login link next time).

**Profile Page (Account Info & Order History):** Logged-in users can access their profile page (`pages/profile.html`), which displays account details and past orders. When the profile page loads, `checkUserSession()` detects if the current page is `profile.html` and calls `loadUserProfile()`. This function fetches additional profile info and the user’s order history from the backend. Specifically, it requests `/api/userProfiles?userId=<currentUser.id>` for any extended profile details (like phone, DOB), and `/api/orders?userId=<currentUser.id>` to retrieve all orders placed by the user. It also fetches `/api/statuses` (order status definitions, e.g., Pending, Shipped) to map status IDs to human-readable names, and all `/api/products` to map product IDs to product data (for naming the items in orders). After these asynchronous calls, it compiles an **Order History** section in HTML. Each order is sorted by date (newest first) and displayed as a card showing the order number, date, status, total amount, and an itemized list of what was purchased. For each item in an order, the code looks up the product name via the earlier product map and displays the item name, quantity, and subtotal price. If the user has no orders, the profile shows a message encouraging them to start shopping. Above the order history, the profile page also shows basic account info: display name, email, role (User vs Admin), and the member since date (formatted from the user’s `createdAt`). This read-only profile page allows the user to review their account and past purchases. (No functionality to edit profile info is provided in this app – the profile is purely for display and order tracking.)

**Access Control (Admin vs User):** The application enforces a simple front-end access control for admin pages. In `checkUserSession()`, if the browser is on `admin.html` but the current user is not logged in or not an Admin, the code will alert “Access denied. Admin privileges required.” and redirect the user to the login page. This prevents non-admin users from even viewing the admin panel UI. Additionally, the presence of the “Admin Panel” link in navigation is conditional on the user’s role being Admin, as mentioned earlier. (Note that this is client-side protection; a determined user could still attempt to call admin API endpoints directly – server-side checks would be needed in a real app. But for this project, the JSON server allows any request, so the front-end gating is the primary restriction.)

## Shopping Cart and Checkout Process

**Cart Data Structure:** The webshop supports a shopping cart that persists between pages and allows checkout. The cart is represented by a global `currentCart` object in the front-end script. The application distinguishes between **guest carts** (for not-logged-in users) and **user carts** (for logged-in users). During page load, `initializeCart()` is called to set up the cart state. If a user is logged in (`window.currentUser` exists), `initializeCart` attempts to load that user’s cart from the backend by querying `/api/carts?userId=<user.id>`. The JSON server’s response is an array of carts (there should typically be at most one active cart per user), and the code picks the one matching the current user or leaves `currentCart = null` if none is found. For a **guest user** (no currentUser), `initializeCart` looks for a saved cart in localStorage (key: `guestCart`). If found, it parses that into `currentCart`; if not, it creates a new guest cart object with a unique id (like `"guest_cart_<timestamp>"`), `userId: null`, empty `items` array, and sets an expiration timestamp a week in the future. This new guest cart is saved to localStorage for persistence. In either case, after initialization, `updateCartUI()` is called to refresh the cart icon in the navigation.

**Adding Items to Cart:** When the user clicks “Add to Cart” for a product, the function `addToCart(productId, quantity=1)` is invoked. This is a high-level handler that delegates to either `addToUserCart` or `addToGuestCart` depending on the login state. If no cart was initialized yet (`currentCart === null`), it will call `initializeCart()` on the fly, ensuring `currentCart` exists before proceeding.

* **Logged-in Users:** `addToUserCart(productId, quantity)` handles adding an item to a server-side cart. If the user had no cart loaded (e.g., first item they add), the code creates a new cart object with a new unique ID (prefixed with `"cart_userId_timestamp"`) containing that item and posts it to `/api/carts` to save it. The newly created cart is then set as `currentCart` in memory. If the user already has a `currentCart`, the code checks if the product is already in the cart’s `items`. If so, it increments the quantity; if not, it appends a new item entry with that productId and quantity. It then updates the cart’s `updatedAt` timestamp and sends a PUT request to `/api/carts/<cart.id>` with the modified cart JSON to update it on the backend. This way, the server’s cart data stays in sync with the client’s actions.

* **Guests (Not Logged In):** `addToGuestCart(productId, quantity)` performs a similar update but all in local memory/storage. If no `currentCart` exists (which means no guest cart was initialized), it creates one (just as in `initializeCart`). Then it checks for an existing item in `currentCart.items`; if found, increases its quantity, otherwise pushes a new item object. The `updatedAt` is refreshed and the entire `currentCart` is saved back to `localStorage` (since guest carts reside there rather than on the server).

After adding the item for either case, `addToCart` will display a brief confirmation message on the UI – “Item obtained!” – via `showMessage(...)` and update the cart icon count with `updateCartUI()`. If the user is currently viewing the cart page when adding an item, it also calls `loadCartPage()` to immediately refresh the cart contents listing. The function returns `true` on success, allowing the calling code to re-enable buttons, etc.. (On failure, an error message “Failed to obtain item” is shown instead.)

**Cart Icon and Badge:** The navigation bar’s Cart link dynamically shows the number of items in the cart. The `updateCartUI()` function calculates the total item count by summing all item quantities in `currentCart`. It then updates the DOM: if a badge element exists from before, it’s removed to avoid duplicates. If the count is greater than 0, a new `<span class="cart-badge">` with the count is created and appended to the Cart link. The Cart link’s text becomes “Cart \[N]” with N items. If the cart is empty, it simply shows “Cart” with no badge. This update runs on every cart change, giving the user immediate feedback on how many items are in their cart.

**Viewing the Cart (Cart Page):** The cart has its own page (`pages/cart.html`). When this page loads, the script calls `loadCartPage()` to render the cart contents. This function ensures the `currentCart` is initialized (calling `initializeCart()` if needed). If after this there is still no cart or the cart is empty (`items.length === 0`), it populates the container with a friendly message: “Your inventory is empty.” and a button linking back to the shop (home page). No table is shown in that case. If there are items, the code will iterate through each item in `currentCart.items` and fetch the full product details for each (`fetchProduct(item.productId)`) from the API. (This ensures it has the latest name and price for each product, as the cart only stored the product ID and perhaps an outdated price.) For each cart item, it calculates the line total = unit price \* quantity and accumulates a subtotal. It then builds an HTML table row with columns: **Item name**, **Unit Price**, **Quantity** (with a special quantity selector UI), **Total**, and **Actions**. The quantity cell is rendered as a small widget with “-” and “+” buttons and an `<input>` box in between for manual entry. The Actions column contains a “Remove” button for each item. After looping all items, the code computes the grand total (which in this app is just the subtotal, as no extra fees), and displays a **Total Gil** at the bottom of the table along with two action buttons: **Clear All** (to empty the cart) and **Purchase** (to proceed to checkout). All of this is wrapped in a styled container (with a “ff7-window” class to match the theme) before inserting into the page. Finally, `setupCartEventListeners()` is called to activate the interactive elements of this table.

**Cart Interaction (Quantity Updates & Removal):** The `setupCartEventListeners()` function enables the cart page’s interactive controls. It attaches click handlers to the “-” (decrease) and “+” (increase) buttons for each item’s quantity, as well as change handlers on the quantity input fields. When a plus or minus button is clicked, the code finds the corresponding item’s `<tr>` (row) and reads the current quantity from the input. It then adjusts the quantity up or down (ensuring it stays between 1 and 99), updates the input display, and calls `updateCartItemQuantity(productId, newQty)` to apply the change to the cart data. The `updateCartItemQuantity` function will either remove the item if `newQuantity <= 0` or set the new quantity and update timestamps, then persist the change (PUT to server cart or update localStorage for guest). After updating data, it calls `updateCartUI()` to refresh the badge and (on success) does not reload the whole page immediately but the values in the table row are already changed. If the user manually types a number in the input and then leaves the field, the `change` event triggers a similar routine (clamping the value to 1–99 and calling `updateCartItemQuantity`).

For item removal, each “Remove” button (`.remove-item-btn`) gets a click listener that on click plays a sound and asks for confirmation (“Remove this item from your inventory?”). If confirmed, it calls `removeFromCart(productId)` which will filter that item out of `currentCart.items` and update the backend or localStorage accordingly. After removal, the code calls `loadCartPage()` again to regenerate the cart table UI without the removed item. There is also a **Clear All** button for the whole cart: its handler asks confirmation (“Clear all items from inventory?”), then shows a transitional overlay (“Clearing Inventory...”), calls `clearCart()` to wipe the cart, and after a short delay reloads the page content. The `clearCart()` function deletes the entire cart: for logged-in users it sends a DELETE request to `/api/carts/{cart.id}` to remove it from the database, and for guests it just removes the `guestCart` from localStorage. It then sets `currentCart = null` and updates the UI badge to zero. Thus, the cart page gives full control to modify quantities or remove items before finalizing the purchase.

**Checkout Process (Order Creation):** When the user clicks the “Purchase” button on the cart page, the `checkoutBtn` triggers `handleCheckout()`. The checkout procedure is implemented as follows:

* **Login Requirement:** First, it ensures the user is logged in. If `window.currentUser` is absent (meaning a guest is trying to checkout), the function shows an error message “Please access the member terminal first.” and then redirects the user to the login page after 1.5 seconds. This effectively forces users to create an account or log in before completing an order. (Guest checkout is not allowed in this app; the rationale might be to have user association for orders.)

* **Order Preparation:** If the user is logged in, the code begins processing the order. It gives immediate feedback by changing the “Purchase” button text to “Processing...” and disabling it to prevent duplicate clicks. Then it constructs the order details: it maps over each item in `currentCart.items` and fetches the latest product data for each (via `fetchProduct`). This is done with `Promise.all` to fetch in parallel. The result is an array of `detailedItems`, where each item includes `productId`, `unitPrice` (price at time of checkout), `quantity`, and `subtotal` (price \* quantity). Using these, the total order amount is calculated by summing all subtotals.

* **Saving the Order:** A new order object is then created and sent to the backend. The helper `createOrder(orderData)` is called with the computed items and total. Inside `createOrder`, an order object is constructed containing:

  * a unique `id` (e.g., `"ord_<timestamp>"`),
  * an `orderNumber` (formatted as `YYYY-XXXXXX` where the numeric part is derived from the timestamp),
  * the `userId` of the current user (or null for guest, though in this flow user is guaranteed to exist),
  * a `statusId` initialized to 1 (likely representing “Pending” status),
  * a currency code (hardcoded "EUR" in this project),
  * the calculated total and the array of items (each including product IDs, quantities, unit prices, subtotals),
  * timestamps for createdAt/updatedAt.
    This object is posted to `/api/orders` via a fetch POST call. If the response is OK (order successfully saved in the JSON DB), the `createOrder` function will call `clearCart()` to empty the user’s cart (both locally and on the server). Clearing the cart ensures the items are not still in the cart after checkout. The newly created order object is returned to the caller.

* **Post-Checkout Feedback:** Back in `handleCheckout()`, if the order was created without errors, the user is shown a success message such as “Purchase complete! Thank you for your business.”. The page then waits 1 second and refreshes the cart page (`loadCartPage()`). The cart page will now detect an empty cart and show the “inventory is empty” message, confirming that the checkout cleared their cart. In case any error occurs during the order creation (network failure, etc.), the code catches it, logs the error, and displays “Transaction failed. Please try again.” to the user. It also re-enables the Purchase button and resets its text so the user can attempt again.

**Payment Handling:** It’s important to note that this application does **not** integrate with a real payment gateway. The “checkout” process above simply creates an order record in the system, assuming payment. The `statusId` for new orders is set to 1 (which in the `statuses` data corresponds to “Pending”), and could be updated later to “Paid” (status 2) if payment was confirmed, but that flow isn’t implemented here. Essentially, the app simulates the purchase by recording the order; it does not process credit cards or external payments. The currency is fixed as EUR and prices are treated as amounts in “Gil” (Final Fantasy themed currency) but effectively in euros for calculation. Thus, the checkout flow is about order submission and clearing the cart, rather than any real payment transaction.

## Additional Features and Admin Panel

### Navigation & UI Feedback

The site uses simple multi-page navigation. Besides the dynamic auth links discussed earlier (Login vs Profile/Admin), the header has a “Home” link and “Cart” link always present. Clicking “Cart” triggers a small animation: it plays a sound and shows a brief transition text “Accessing Cart...” before redirecting to the cart page. Similarly, clicking Home (if implemented with a special handler) might play a sound and transition (the code sets up a click on `#home` to play a sound). These are aesthetic touches to mimic a game-like interface. The function `showPageTransition(text)` creates a screen overlay with a message (e.g., “Loading Item Details…”, “Clearing Inventory…”) and a Final Fantasy VII style transition sound. This is purely visual feedback during navigation or actions.

Additionally, the app includes a sound system (`playFF7Sound`) with an `FF7_SOUNDS` lookup for different event sounds (menu select, cursor move, error buzz, item obtained fanfare, etc.). Whenever key actions occur (navigation clicks, form submissions, etc.), the code calls `playFF7Sound("menu_select")` or other appropriate cues to enhance the user experience. There’s also an **Audio Toggle** button created by `initializeAudioToggle()` that lets the user turn sound ON/OFF (it toggles a global volume and updates the button text). These audio/visual features are not core to functionality but show how state (like sound enabled/disabled) is managed via a combination of global variables and localStorage (`ff7_sound_enabled`).

### Admin Panel (Management of Products, Categories, Users, Orders)

The **Admin Panel** is a crucial feature for administrative users. It is implemented as a separate page `pages/admin.html` with its own script `admin.js`. Only users with the Admin role (roleId 2) should access it. The UI is organized into tabs for managing **Products**, **Categories**, **Users**, and **Orders**, all visible on the admin page when logged in as admin.

When `admin.html` loads, it includes `admin.js` which runs an initialization on DOMContentLoaded. The `initializeAdmin()` function sets up event listeners on the tab links (“Products”, “Categories”, “Users”, “Orders”) to switch the visible section when clicked. It also sets up handlers for opening modal dialogs for adding new products or categories, and attaches form submission handlers for the product and category forms. After initialization, `loadAllData()` is called to populate all sections.

**Product Management:** The admin Products tab shows a list of all products in the system. The data is fetched from `/api/products` via `loadProducts()`, then rendered by `displayProducts(products)`. In the admin context, `displayProducts` creates a simplified list: for each product, it displays the name, ID, description, categoryId, price, and tags, along with Edit and Delete buttons. The HTML is generated as a string with each product in an `.admin-item` div. The Edit button is wired to call `editProduct('<productId>')` and Delete calls `deleteProduct('<productId>')` via inline `onclick` attributes in the generated HTML. Clicking **“Add New Product”** opens a modal form (using Bootstrap modal markup) for adding a product. This modal’s fields include Product ID, Name, Description, Category (a dropdown), Price, Tags, and Images URLs. The code populates the category dropdown by loading all categories (`loadCategoriesForSelects()`) and inserting each category as an option so the admin can choose a category for the product.

When the product form is submitted, `handleProductSubmit(e)` runs. This function gathers the form inputs into a `product` object. If an existing product is being edited, it retains the original `createdAt`; otherwise it sets a new `createdAt` timestamp. It also splits the comma-separated tags and image URLs into arrays (trimming whitespace). Then it determines whether to create or update: if `currentEditingProduct` is set (meaning we opened the modal in edit mode), it sends a PUT request to `/api/products/<id>` with the updated product JSON; if adding new, it sends a POST to `/api/products`. Notably, for new products the admin must provide a unique ID manually in the form (the code doesn’t auto-generate product IDs, so the admin chooses an identifier). On a successful response (`response.ok`), the modal is closed, `loadProducts()` is called again to refresh the list, and an alert notifies the admin that the product was created/updated. If the save fails, an error is logged and an alert “Error saving product” is shown.

The **Edit Product** button for each item triggers `editProduct(productId)`. This performs a fetch to `/api/products/{id}` to get the full product data, then calls `openProductModal(product)` with that data. `openProductModal(product)` marks that we’re editing by setting a global `currentEditingProduct`, fills the modal form fields with the product’s data via `populateProductForm(product)`, and then displays the modal dialog. The form fields for tags and images are populated by joining the arrays into comma-separated strings for easy editing. For **Add Product**, `openProductModal()` is called with no argument when the “Add New Product” button is clicked. In that case, it clears any previous state, sets the modal title to "Add Product", resets the form, and shows the modal. Both add and edit actions use the same form; the difference is just whether it was pre-filled and whether the submit does POST or PUT (controlled by `currentEditingProduct`).

Deleting a product is straightforward: the Delete button calls `deleteProduct(productId)`. This asks for confirmation (`confirm('Are you sure…')`), then sends a DELETE request to `/api/products/{id}` if confirmed. On success, it reloads the product list and alerts “Product deleted successfully!”. If there’s an error, it alerts the admin that deletion failed.

**Category Management:** The Categories tab similarly lists all product categories. Categories have an ID, name, optional parent category, and a creation date. The admin UI fetches categories via `loadCategories()` and uses `displayCategories(categories)` to render them. Each category entry in the list shows its name, ID, parentId (if any), and created date. Admins can add a new category or edit an existing one. The “Add New Category” button opens a category modal form with fields for category name and a dropdown to choose a parent category (for hierarchical categorization). The parent dropdown is populated by `loadCategoriesForSelects()`, which adds all categories as options (plus an option for “None (Top Level)” for no parent). When the category form is submitted, `handleCategorySubmit(e)` runs. It builds a `category` object from the form (name and parentId). If editing an existing category, it includes the same `id` and original `createdAt`; if new, it leaves the ID to be assigned by the JSON server and sets a new timestamp. The function then sends either a PUT (if editing) or POST (if new) to the `/api/categories` endpoint with this category data. On success, it closes the modal, refreshes the category list and also refreshes the category dropdowns (so that new categories become available for product assignments or as parent categories). A success alert is shown to the admin. Deletion of categories is handled by `deleteCategory(id)` which is nearly identical to product deletion: confirm, then DELETE request, and on success reload the categories and update dropdown options. (If a category that is a parent to others is deleted, those others might become orphan unless the backend or admin logic prevents it – in this simple implementation there isn’t additional enforcement of category hierarchy consistency beyond what the admin does manually.)

**User Management:** The Users tab on the admin page lists all user accounts in the system. It loads users via `loadUsers()` (GET `/api/users`) and displays them with `displayUsers(users)`. Each user entry shows the displayName, ID, email, roleId, and created date. Unlike products and categories, the admin interface does not provide a form to add new users or edit existing ones – user creation is expected to happen via the normal registration flow, and user updates (like password changes or role changes) are not exposed in the UI. The only action available to admins here is to **delete a user**. Each user entry has a Delete button that calls `deleteUser(userId)`. This, again, asks for confirmation and then issues a DELETE request to `/api/users/{id}`. If successful, it reloads the user list and alerts “User deleted successfully!”. (Internally, JSON-server will remove that user from the DB. The front-end login logic also checks for `deletedAt` on users, so if a user were marked deleted instead of removed, they couldn’t log in. In this implementation, the deletion likely removes the record entirely.) Admins might use this to remove problematic users or test accounts. There is no edit, since things like changing roles or emails would require additional UI not present here.

**Order Management:** The Orders tab gives the admin a view of all orders in the system. On admin page load, `loadOrders()` fetches all orders, all statuses, and all users in parallel (using `Promise.all`). Once retrieved, `displayOrders(orders, statuses, users)` is called to render a summary list. Each order entry shows the order number, customer name (it finds the user by matching `order.userId` to the users list; if no userId, it labels them “Guest”), the date/time of the order, the status name (by matching `statusId` to the statuses list), and the total amount. The admin view of orders is read-only; there are no buttons to edit status or view details here. It’s mainly for oversight. If there are no orders, it will say “No orders found.”. In a real application, one might allow an admin to update an order’s status (e.g., mark as Shipped/Delivered), but in this project those capabilities are not implemented – statuses exist in the data model, but changing them would require either an admin form or directly editing the JSON. As it stands, the admin Orders tab is informational.

**Tech Stack and Data Flow:** The front-end code (HTML/JS/CSS) interacts with a JSON-based API. The backend is powered by [JSON-Server](https://github.com/typicode/json-server) which serves `db.json` content via RESTful endpoints (this is set up in `index.cjs`). The `API_BASE_URL` is `"/api"`, so for example `/api/products` or `/api/orders` correspond to sections of the JSON database. The Node/Express server also includes logic to sync the `db.json` with the GitHub repository, ensuring data persists (especially when running on Render.com). Whenever the admin adds or edits items, those changes go through the API and end up updating `db.json`. The sync mechanism (not visible to end-user but in code) either writes to GitHub or pulls updates on intervals so that the database file remains consistent. In essence, the JSON file is acting as a simple database; all core data (users, products, carts, orders, etc.) flows from this file via API calls to the front-end, where it is then rendered in the UI or updated based on user actions.

**State Management Approach:** Since this is not a React or Angular application, there are no hooks or Redux store – instead, state is managed through plain JavaScript variables and the DOM. Global variables like `window.currentUser` and `currentCart` hold important state in memory. Persistence is achieved with localStorage for things that need to survive page reloads (user session token, guest cart contents, sound preferences). The application logic is split across a few script files (auth.js for authentication and user session, script.js for general site functionality and cart, admin.js for admin interface). They communicate via the shared global state (for example, script.js checks `window.currentUser` which is set by auth.js). UI state (like the content of the cart page or profile page) is not managed by a virtual DOM but by directly manipulating innerHTML or creating DOM elements. For instance, the product listing is re-rendered by setting `container.innerHTML` in one go, and the cart page reconstructs its entire table on changes. This is an imperative, straightforward approach suitable for a small app. Modal visibility and tab switching are managed by adding/removing CSS classes (`active`) or using Bootstrap’s built-in modal controls (the HTML includes Bootstrap classes, and some modals are toggled by adding `style.display = 'block'` in JS).

In summary, **Wall Market Online** is a classic web-shop implementation using a JSON server backend and vanilla JavaScript front-end. Products are fetched and displayed as cards with interactive buttons; users can register/login, which updates navigation and allows access to profile and admin features. The cart system handles both guests and logged-in users by storing cart data appropriately and syncing with the backend for persistence. The checkout sequence creates an order entry and clears the cart. Additionally, the application provides an admin panel where privileged users can manage the catalog (products/categories), user accounts, and view orders, all through form submissions that interact with the JSON API. Throughout the code, functions are well-defined for each piece of functionality – from `handleLogin` for authentication to `loadCartPage` for rendering the cart, to `handleProductSubmit` for saving products – enabling an in-depth understanding of each operation at the function level. This modular organization and the use of consistent web APIs (`fetch`) and DOM manipulation calls make it easier to trace the data flow from database to UI and vice versa for each core feature of the system.
